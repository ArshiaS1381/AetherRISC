using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace AetherRISC.Generators
{
    [Generator]
    public class InstGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // 1. Find all classes ending in "Instruction"
            var instructions = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: (s, _) => s is ClassDeclarationSyntax c && c.Identifier.Text.EndsWith("Instruction"),
                    transform: (ctx, _) => (ClassDeclarationSyntax)ctx.Node)
                .Where(c => c != null);

            // 2. Generate the code
            context.RegisterSourceOutput(instructions.Collect(), (spc, classes) =>
            {
                var sb = new StringBuilder();
                var namespaces = new HashSet<string>();

                // Header
                sb.AppendLine("// <auto-generated/>");
                sb.AppendLine("using AetherRISC.Core.Abstractions.Interfaces;");
                
                // Collect namespaces
                foreach (var cls in classes)
                {
                    // FIX: Skip Abstract classes and the base "Instruction" class
                    if (cls.Modifiers.Any(m => m.Text == "abstract")) continue;
                    if (cls.Identifier.Text == "Instruction") continue;

                    if (cls.Parent is BaseNamespaceDeclarationSyntax ns) namespaces.Add(ns.Name.ToString());
                    else if (cls.Parent is FileScopedNamespaceDeclarationSyntax fns) namespaces.Add(fns.Name.ToString());
                }

                foreach (var ns in namespaces) sb.AppendLine($"using {ns};");
                
                sb.AppendLine();
                sb.AppendLine("namespace AetherRISC.Core.Helpers");
                sb.AppendLine("{");
                sb.AppendLine("    public static class Inst");
                sb.AppendLine("    {");

                // Generate Methods
                foreach (var cls in classes)
                {
                    // FIX: Apply the same filter here
                    if (cls.Modifiers.Any(m => m.Text == "abstract")) continue;
                    var className = cls.Identifier.Text;
                    if (className == "Instruction") continue;

                    var methodName = className.Substring(0, className.Length - 11); // "Add"

                    // Find all public constructors
                    var ctors = cls.Members.OfType<ConstructorDeclarationSyntax>()
                        .Where(c => c.Modifiers.Any(m => m.Text == "public"));

                    // Track signatures to prevent duplicates (e.g. if partial classes exist)
                    var signatures = new HashSet<string>();

                    foreach (var ctor in ctors)
                    {
                        var paramList = ctor.ParameterList.Parameters;
                        
                        // Signature: "int rd, int rs1"
                        var signatureParams = string.Join(", ", paramList.Select(p => $"{p.Type} {p.Identifier}"));
                        
                        if (signatures.Contains(signatureParams)) continue;
                        signatures.Add(signatureParams);

                        // Call Args: "rd, rs1"
                        var callArgs = string.Join(", ", paramList.Select(p => p.Identifier.Text));

                        sb.AppendLine($"        public static IInstruction {methodName}({signatureParams}) => new {className}({callArgs});");
                    }
                    
                    // Fallback for implicits (like NOP) if no explicit constructor found
                    if (!ctors.Any())
                    {
                         sb.AppendLine($"        public static IInstruction {methodName}() => new {className}();");
                    }
                }

                sb.AppendLine("    }");
                sb.AppendLine("}");

                spc.AddSource("Inst.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
            });
        }
    }
}
