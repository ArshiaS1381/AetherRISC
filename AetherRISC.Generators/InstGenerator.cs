using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace AetherRISC.Generators
{
    [Generator]
    public class InstGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var instructions = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: (s, _) => s is ClassDeclarationSyntax c && c.Identifier.Text.EndsWith("Instruction"),
                    transform: (ctx, _) => (ClassDeclarationSyntax)ctx.Node)
                .Where(c => c != null);

            context.RegisterSourceOutput(instructions.Collect(), (spc, classes) =>
            {
                var sb = new StringBuilder();
                var namespaces = new HashSet<string>();
                
                // Collect namespaces of all instructions found
                foreach (var cls in classes)
                {
                    if (cls.Parent is BaseNamespaceDeclarationSyntax ns) namespaces.Add(ns.Name.ToString());
                    else if (cls.Parent is FileScopedNamespaceDeclarationSyntax fns) namespaces.Add(fns.Name.ToString());
                }

                sb.AppendLine("// <auto-generated/>");
                sb.AppendLine("using AetherRISC.Core.Abstractions.Interfaces;");
                sb.AppendLine("using AetherRISC.Core.Architecture.Hardware.ISA;");
                
                // Import all extension namespaces found (e.g. ...Extensions.F, ...Extensions.Zbb)
                foreach (var ns in namespaces) sb.AppendLine($"using {ns};");

                sb.AppendLine();
                sb.AppendLine("namespace AetherRISC.Core.Architecture.Hardware.ISA");
                sb.AppendLine("{");
                sb.AppendLine("    public static class Inst");
                sb.AppendLine("    {");

                foreach (var cls in classes)
                {
                    if (cls.Modifiers.Any(m => m.Text == "abstract")) continue;
                    var className = cls.Identifier.Text;
                    if (className == "Instruction") continue;

                    // Strip "Instruction" suffix for the method name (e.g. AddInstruction -> Add)
                    var methodName = className.Substring(0, className.Length - 11);
                    
                    var ctors = cls.Members.OfType<ConstructorDeclarationSyntax>().Where(c => c.Modifiers.Any(m => m.Text == "public"));

                    foreach (var ctor in ctors)
                    {
                        var paramList = ctor.ParameterList.Parameters;
                        var signatureParams = string.Join(", ", paramList.Select(p => $"{p.Type} {p.Identifier}"));
                        var callArgs = string.Join(", ", paramList.Select(p => p.Identifier.Text));
                        
                        // Avoid duplicates if multiple ctors have same signature (rare but possible)
                        sb.AppendLine($"        public static IInstruction {methodName}({signatureParams}) => new {className}({callArgs});");
                    }
                    
                    // Handle implicit parameterless constructor if no public constructors exist
                    if (!ctors.Any()) sb.AppendLine($"        public static IInstruction {methodName}() => new {className}();");
                }

                sb.AppendLine("    }");
                sb.AppendLine("}");
                
                spc.AddSource("Inst.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
            });
        }
    }
}
